#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

// TODO: Add bindings to:
// 1. Store the input blades
// 2. Write out the culled blades
// 3. Write the total number of blades remaining

// The project is using vkCmdDrawIndirect to use a buffer as the arguments for a draw call
// This is sort of an advanced feature so we've showed you what this buffer should look like
//
layout(set = 2, binding = 2) buffer NumBlades {
	  uint vertexCount;   // Write the number of blades remaining here
	  uint instanceCount; // = 1
	  uint firstVertex;   // = 0
	  uint firstInstance; // = 0
} numBlades;

layout(set = 2, binding = 1) buffer BladesIn {
	  Blade[] blades;
} bladesIn;

layout(set = 2, binding = 0) buffer BladesOut {
	  Blade[] blades;
} bladesOut;

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

void main() {
	// Reset the number of blades to 0
	if (gl_GlobalInvocationID.x == 0) {
		numBlades.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

    // TODO: Apply forces on every blade and update the vertices in the buffer
    
    // Recovery Force
    // Initial pose of V2 is v0 + up * height
    const Blade currentBladeIn = bladesIn.blades[gl_GlobalInvocationID.x];
    vec3 I_V2 = currentBladeIn.v0.xyz + currentBladeIn.up.xyz * currentBladeIn.v1.w;
    const vec3 recoveryForce = (I_V2 - currentBladeIn.v2.xyz) * currentBladeIn.up.w;
    //const vec3 recoveryForce = vec3(0.0);

    // Gravity
    const vec3 gravityDir = normalize(-currentBladeIn.up.xyz);
    const float gravityAccel = 9.8;
    const vec3 gravityForceE = gravityAccel * gravityDir;
    const vec3 forwardDir = normalize(vec3(cos(currentBladeIn.v0.w), 0, sin(currentBladeIn.v0.w)));
    const vec3 gravityForceF = length(gravityForceE) * forwardDir * 0.25;
    //const vec3 gravityForceTotal = gravityForceE + gravityForceF;
    const vec3 gravityForceTotal = vec3(0.0);

    // Wind
    const vec3 windDir = vec3(cos(totalTime * 0.25 + currentBladeIn.v0.x * currentBladeIn.v2.z), 0.0, sin(totalTime - currentBladeIn.v0.z * 0.25)) * 2.5;
    const float directionalAlignment = 1.0 - length(windDir - normalize(currentBladeIn.v2.xyz - currentBladeIn.v0.xyz));
    const float heightRatio = dot((currentBladeIn.v2.xyz - currentBladeIn.v0.xyz), currentBladeIn.up.xyz) / currentBladeIn.v1.w;
    const vec3 windForce = heightRatio * directionalAlignment * windDir;
    //const vec3 windForce = vec3(0.0);

    vec3 totalForce = recoveryForce + gravityForceTotal + windForce;
    totalForce *= deltaTime;

    // Move V2 and V1 properly
    Blade bladeOut;

    bladeOut.v2.xyz = currentBladeIn.v2.xyz + totalForce;

    // Pass v0
    bladeOut.v0 = currentBladeIn.v0;

    // Pass up
    bladeOut.up = currentBladeIn.up;

    // Move V2
    bladeOut.v2.xyz = bladeOut.v2.xyz - bladeOut.up.xyz * min(dot(bladeOut.up.xyz, bladeOut.v2.xyz - bladeOut.v0.xyz), 0.0);
    bladeOut.v2.w = currentBladeIn.v2.w;

    // Move V1
    const float lProj = length(bladeOut.v2.xyz - bladeOut.v0.xyz - bladeOut.up.xyz * dot(bladeOut.v2.xyz - bladeOut.v0.xyz, bladeOut.up.xyz));
    bladeOut.v1.xyz = bladeOut.v0.xyz + currentBladeIn.v1.w * bladeOut.up.xyz * max(1.0 - lProj / currentBladeIn.v1.w, 0.05 * max(lProj / currentBladeIn.v1.w, 1.0));
    bladeOut.v1.w = currentBladeIn.v1.w;

    // Check length of the Bezier curve
    const float L0 = length(bladeOut.v2.xyz - bladeOut.v0.xyz);
    const float L1 = length(bladeOut.v2.xyz - bladeOut.v1.xyz) + length(bladeOut.v1.xyz - bladeOut.v0.xyz);
    const float n = 2.0; // degree 2 Bezier curve
    const float L = (2.0 * L0 + (n - 1.0) * L1) / (n + 1.0);
    const float r = currentBladeIn.v1.w / L;
    bladeOut.v1.xyz = bladeOut.v0.xyz + r * (currentBladeIn.v1.xyz - bladeOut.v0.xyz);
    bladeOut.v2.xyz = bladeOut.v1.xyz + r * (bladeOut.v2.xyz - currentBladeIn.v1.xyz);

	// TODO: Cull blades that are too far away or not in the camera frustum and write them
	// to the culled blades buffer
	// Note: to do this, you will need to use an atomic operation to read and update numBlades.vertexCount
	// You want to write the visible blades to the buffer without write conflicts between threads

    bool shouldCull = false;
    
    // cull stuff

    if(!shouldCull) {
        // Increment num blades
        atomicAdd(numBlades.vertexCount, 1);
    }

    bladesOut.blades[gl_GlobalInvocationID.x] = bladeOut;
    bladesIn.blades[gl_GlobalInvocationID.x] = bladeOut;
}
